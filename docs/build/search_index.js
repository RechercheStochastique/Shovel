var documenterSearchIndex = {"docs":
[{"location":"Stop/#Estimation-for-a-single-qubit","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"","category":"section"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"When a qubit in state alphaket0 + betaket1 is measured, it either returns 0 or 1 with probability p=alpha^2 and 1-p=beta^2 = 1-alpha^2. The objective of a quantum computer program is often to get the value of alpha. So the program is run a large number of time and the relative frequancy of zeros is computed. By the law of large numbers that proportion will converge to alpha^2. The number of time the programs needs to run depends on the desired precision of the estimate. This precision is defined as a interval of confidence. That is, a maximum distance between the real value of alpha and the value of the estimate with a minimum probability. This can be rephrase as: {\\it the estimate does not differ from the real value by more than Delta with a probability greater than 1-gamma}. The parameters Delta and gamma are fixed by the program user and the program is run until the precision is met.","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"Unfortunately, the number is required iterations is dependant on the unknown value so the user is left to do trial until the result is satisfactory.","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"In the following paper we presents a method to sequentially assess is a sufficient number of iterations have been done to meet the precision requirements. The users simply enters the precision parameters Delta and gamma and let the program iterate until it is reached.","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"In the first section we present the methods for estimating alpha^2 for one qubit at a time. We then address the case for f(alpha^2). In the next section we address the problem of estimating several qubits at the same time. We then consider the problem of noise in the estimation process.","category":"page"},{"location":"Stop/#Sampling-for-\\alpha2","page":"Estimation for a single qubit","title":"Sampling for alpha^2","text":"","category":"section"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"Suppose the qubit is measured N times and let X_1 X_2X_N be the observed values. We have that Pbig( X_n = 0) =  alpha ^2 = p big), hence the following natural estimator of alpha ^2.","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"Let S_N = X_1++X_N, F_N= N - S_N and","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"hatp = widehat alpha ^2 = fracS_NN","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"The variance of this estimator is given by:","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"Vbig( hatp big) = fracp ( 1- p)N","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"If M is large, then  ","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"Z= sqrtfracNp(1-p)(hatp - p )","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"has an approximate normal distribution with mean 0 and variance 1. ","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"If one is interested in getting a estimate of p with a fixed minimal precision, it will usually be in the form of a interval  hatp-Delta hatp+Delta havin a probability 1-gamma of containing the true unknown p. Typically, Delta is defined by the number of significant digits: Delta =2times 10^-k, where k is the number of digits. The confidence level is defined by a small value of gamma such as 5\\%, 1\\% or even less. The smaller the value of gamma the more likely the probability for the interval to include the real, but unknown, value of p.","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"Using the asymptotic normal distribution of Z in (\\ref{Z.eq}), let Phi()^-1 be the inverse of the normal cumulative distribution function and set","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"z = Phi^-1big( 1- gamma2 big)","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"We seek N such that","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"beginaligned\r\n 1- gamma2 =  Pbigg -z  sqrtfracNp(1-p)(hatp - p )  z bigg  \r\n= Pbigg -z sqrtfracp(1-p)N  (hatp - p )  z sqrtfracp(1-p)N bigg \r\nendaligned","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"The length of the interval is therefore given by 2zsqrtp(1-p)N and must be less or equal to 2Delta, hence:","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"N = p(1-p) bigg fracPhi^-1big( 1- gamma2 big)Delta bigg^2","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"where the constant Phi^-1big( 1- gamma2 big)  Delta is large given that Phi^-1big( 1- gamma2 big) is larger than 1 and that Delta is usually a small number accounting for the number of correct digits.","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"The problem with equation (\\ref{simpleN.eq}) is that is relies on the knowledge of p which is precisely what we are trying to find. One option is the take the worst case, which happens when p=12. In this case (\\ref{simpleN.eq}) becomes:","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"N = bigg fracPhi^-1big( 1- gamma2 big)2Delta bigg^2","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"As an example, with Delta=00001 and gamma=005, we have N = 95,062,500.","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"An alternate solution is to go sequentially and update the target number of trial as we get a better estimate of N.","category":"page"},{"location":"Stop/#Sequential-Estimation","page":"Estimation for a single qubit","title":"Sequential Estimation","text":"","category":"section"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"If we proceed sequentialy, the sample size is increased progressively and, at each step, a decision is taken as to continue or stop.","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"I would be tempting to simply reuse equation \\ref{simpleN.eq} with hatp estimated after a few steps to compute N with:","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"N = hatp(1-hatp) bigg fracPhi^-1big( 1- gamma2 big)Delta bigg^2 = frac S_NF_NN^2 bigg fracPhi^-1big( 1- gamma2 big)Delta bigg^2","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"Setting","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"H(gammaDelta)= bigg( frac Phi^-1big( 1- gamma2 big)Delta bigg)^23","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"we have:","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"N=  big( S_NF_N big)^13H(gammaDelta)","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"On average, big( S_NF_N big)^13 increases at rate N^23. Hence, at one point N will become greater and sampling should stop.","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"There is one problem however with equation \\ref{eq.seq1}. At the beginning of the process it is very likely to get several zeros in a row without ones (or the reverse). It that case, sqrtS_NF_N is null and the process should stop immediately. This situation is more likely to happen when p is close to either 1 (or 0 for the reverse situation).","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"Setting a minimal number of trial before we start comparing N with S_NF_N would be an option. In order to determine such a value we must consider the case where p is very small and remember that is are satisfied with a precision of Delta for our estimate. So any value of p estimated to be 0 while it is in fact smaller than Delta is acceptable. ","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"Assume now that p=Delta, so that the probability that X_n=1 is very high. Then the probability of getting a sequence of N ones in a row is given by (1-Delta)^N. We dont want to mae the error of claming the p=0 with a higher probability than 1=gamma. Therefore, N must be large enough so that Delta^N1-gamma. Hence, N  log(1-gamma)log(1-Delta). For p1-Delta the result is the same.","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"The final stopping rule is therefore: ","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"Stop samplig when N ge maxbigg fraclog(1-gamma)log(1-Delta)  big( S_NF_N big)^13H(gammaDelta) bigg","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"With Delta=00001 and gamma=005, we have H(005 00001)=727 so :","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"Stop samplig when N ge maxbig 9500  727big( S_NF_N big)^13 big","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"Since S_NF_N approx N^2p(1-p), for p=12 at trial 9,500 we have 727(S_NF_N)^13 approx 727 big(9500^24)^13=205430. In the wost case S_N and F_N are very close (approx N2) and the process will go on until N= 727(N^24)^13 which happens when N=727^34= 96060145 which is very close the worst case with a fixed sample size.","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"For p=14, S_NF_N approx 3N^216 and the process will lkkely stop for N in th neibourhood of (316)727^3= 72045109, less than 19\\% of the worst case.","category":"page"},{"location":"Stop/#Estimation-of-f(\\alpha2)","page":"Estimation for a single qubit","title":"Estimation of f(alpha^2)","text":"","category":"section"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"Often, the parameter that is to be measured is not alpha^2 but alpha=sqrt(alpha^2) or a differentiable function f of it. If f is continually differentiable, then sqrtNbig( f(hatp)-f(p) big) has an asymptotic normal distribution with mean 0 and variance f(p)^2 p(1-p). So,  using the same argument as in the previous section:","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"beginaligned\r\n 1- gamma2 =  Pbigg -z  sqrtfracNf(p)^2 p(1-p)(f(hatp) - f(p) )  z bigg  \r\n= Pbigg -z sqrtfracf(p)^2 p(1-p)N  (hatp - p )  z sqrtfracf(p)^2 p(1-p)N bigg \r\nendaligned","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"The length of the interval is therefore given by 2zsqrtf(p)^2 p(1-p)N and must be less or equal to 2Delta, hence:","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"N = f(p)^2 p(1-p) bigg fracPhi^-1big( 1- gamma2 big)Delta bigg^2","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"We can now use the same sequential method","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"N = f(hatp)^2 hatp(1-hatp) bigg fracPhi^-1big( 1- gamma2 big)Delta bigg^2 = fbigg(fracS_NNbigg)^2 fracS_NF_NN^2 bigg fracPhi^-1big( 1- gamma2 big)Delta bigg^2","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"N= fbigg(fracS_NNbigg)^23 big( S_NF_N big)^13H(gammaDelta)","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"And samplig should continue until N is not greater than the right hand side of \\ref{eq.seq2}.","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"As for the simpler case of estimating alpha^2, we need to deal with the cases of a long sequence of zeros, or ones which could happen when p=0 or p=1, but also when f(p)^2p(1-p) is small. But the way we solved the first situation also resolved the problem of a very small derivate. Since we'll be doing a minimal number of trials equal to log(1-gamma)log(1-Delta), then we know that, with probability no less than 1-gamma, that hatp-p  Delta. And if f(p)^2 le 1, then f(hatp)-f(p)  Delta with the same probability. We therefore have the necessary precision for small values of f(p)^2.","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"The stopping rule becomes:","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"Stop samplig when N ge maxbigg fraclog(1-gamma)log(1-Delta)  fbigg(fracS_NNbigg)^23big( S_NF_N big)^13H(gammaDelta) bigg","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"For example, with f(p)=sqrtp, we have:","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"fbigg(fracS_NNbigg)^23big( S_NF_N big)^13=N^13frac1(4S_N)^13big( S_NF_N big)^13 =bigg(fracN4bigg)^13F_N^13","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"One last improvement could be to get rid of the derivative and estimate it instead of requiring the user to provide a function to do it. Let","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"D_N = big(f(S_NN+Delta)-f(S_NN-Delta)big)2Delta","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"Then we have:","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"Stop samplig when N ge maxbigg fraclog(1-gamma)log(1-Delta)  D_N^23big( S_NF_N big)^13H(gammaDelta) bigg","category":"page"},{"location":"Stop/#Simultaneous-estimation-of-several-qubits","page":"Estimation for a single qubit","title":"Simultaneous estimation of several qubits","text":"","category":"section"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"If dealing with entangled qubits the measure is made on a multinomial distribution. For instance, the two qubits ketpsi_1psi_2 are in state alpha_00ket00+alpha_01ket01+alpha_10ket10+alpha_11ket11, where alpha_00^2+alpha_01^2+alpha_10^2+alpha_11^2 = 1. ","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"Suppose K qubit are to be measured. Then, there are L=2^K possible measurement outcomes. The parameter p is not a scalar anymore but a 2^K-dimensional vector p_1p_L, representing the probability of each of the possible outcomes.","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"Let S_lN the proportion of time the the outcome l appeared and hatp_l=S_NN . Of course sum_l S_lN =N and sum_l hatp_l =1. The variance of hatp_l is equal to p_l(1-p_l)N and the correlation between hatp_l and hatp_m is given by -p_lp_mN.","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"The probability that all outcome estimate will be within less that Delta from their true values is difficult to compute exactly given the correlation. The simplest alternative is to use the Bonferonni method. If a global probability of 1- gamma is desired then the individual probability has to be set as 1-gammaL and use H(gammaL Delta) (\\ref{eq.H}) with the folloing rule:","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"Stop samplig when N ge maxbigg fraclog(1-gammaL)log(1-Delta)  max_l big( S_lNF_lN big)^13H(gammaLDelta) bigg","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"When estimating f(p_1p_L), where f    real^L to real. THen","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"f(hatp_1hatp_L)- f(p_1p_L) = fracpartial fpartial p_1(p)(hatp_1-p_1) +  + fracpartial fpartial p_L(p)(hatp_L-p_L)","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"Hence","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"Vbig( f(hatp_1hatp_L) big) = biggfracpartial fpartial p_1(p)bigg^2 Vbig(hatp_1big)+  + bigg fracpartial fpartial p_L(p)bigg^2 Vbig(hatp_Lbig)","category":"page"},{"location":"Stop/#Sampling-with-external-white-noise","page":"Estimation for a single qubit","title":"Sampling with external white noise","text":"","category":"section"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"So far we have assumed that, when measuring the qubit, the random variable X_n had a binomial distribution with parameter p = alpha^2. This will happen is there is no external noise disturbing the qubit. If this is not the case we can assume that the impact of the external noise is not correlated with the value of the qubit when it switches the lecture. In order to model this we introduce a new random variable Y_n that may change the value of the reading with probability 1-q. If Y_n = 0, then the reading is exact and equals X_n. But if Y_n =1 then output of the qubit is the opposit of the correct value. It will be 1 if X_n=0 and 0 if X_n=1.","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"beginarrayccc\r\n  mbox   beginmatrix X_n=0  X_n = 1 endmatrix \r\n  beginmatrix Y_n=0  Y_n=1 endmatrix \r\n  beginbmatrix hspace10pt 0 hspace15pt  hspace15pt1 hspace10pt  hspace10pt 1hspace15pt  hspace15pt0 hspace10pt endbmatrix\r\nendarray","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"\\caption{Measured output Z_n depending on X_n and Y_n} \\end{figure}","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"The impact of Y_n would be minimal on X_n if p=12 since the change form 0 to 1 would be, on average, ofset by the changes from 1 to 0. However, if p is closer to 0 or to 1, then there is a higher probability the one type of change will happen more frequently than the other. ","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"We have P(Z_n = 0) = P(X_n=0 cap Yn=0) + P(X_n = 1 cap Y_n = 1) = pq + (1-p)(1-q) = pq + 1 - q - p + pq = 1+2pq-p-q=p(2q-1)+(1-q). As we can see, there is a bias introduced in the measurement. So a simple average of the Z_n will lead to an estimation of p(2q-1)+(1-q) instead of the desired p. If q is known then ","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"hatp =fracN^-1sum_n=1^N Z_n -(1-q)(2q-1)","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"is an unbiased estimator for p and preferable to (\\ref{simpleEstim.eq}). If the noise is low, q will be close to 1 and 1-q near 0 and negligeable, while 2q-1 is almost equal to 1 and negligeable as well.","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"The variance of Z_n is then equal to (p+q-2pq)(1-p-q+2pq) and the variance of the estimator in (\\ref{unbiasEstim.eq}) is:","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"V(hatp) =  frac(p+q-2pq)(1-p-q+2pq)N(2q-1)^2","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"And thre sample size can be treated similarly to the previous case as in (\\ref{Nchapeau.eq}). One can see that as q gets near 0.5 the variance will increase and require sample size much larger.","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"The value of q has to be known for (\\ref{unbiasEstim.eq}) to be useful. This can be based on past experiments made on the qubit and could be considered a calibrantion step.","category":"page"},{"location":"Stop/#White-noise-increasing-with-time","page":"Estimation for a single qubit","title":"White noise increasing with time","text":"","category":"section"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"In the previous section we have have assumed that the white noise Y_n was a random variable with a constant probability q of altering the outcome of the measurement. In reality, qubits will progressively become noisier as the time goes by. The probability q is in fact a function of time q(t) which is 0 when t=0 and prgressively increases to 0.5.","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"A qubit is first initialised and them several calculation are done on it using logical gates. As these gates take a certain time to execute this must be added to the time of the qbit. If the time for each gate is a constant T_0 then the time to perform the computation on the qubit is equal to the number of gates multiplied by the time used to execute the gate: q(t) = q(T_0 times mboxNumber of gates in the computation)=q(T_0 K). The function q() could be approximated by an exponential such as:","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"beginaligned\r\nq(t) = 05 big(1-e^-C_0 tbig) \r\n= 05 big(1- e^-C_0T_0 K big) \r\n= 05 big(1- e^-B_0 K big)\r\nendaligned","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"where B_0 is a constant for a given qubit. ","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"Inseting the last line of (\\ref{qExpo.eq}) into equations (\\ref{unbiasEstim.eq}) and (\\ref{varianceUnbiasEstim.eq}) we get:","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"hatp =fracN^-1sum_n=1^N Z_n -(1-05 big(1- e^-B_0 K big))(205 big(1- e^-B_0 K big)-1)","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"and","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"V(hatp) =  fracbig(p+05(1- e^-B_0 K)-2p05(1- e^-B_0 K)big) big(1-p-05(1- e^-B_0 K)+2p05(1- e^-B_0 K)big)Nbig( 205(1- e^-B_0 K )-1big)^2","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"V(hatp) =  fracbig(p+05(1- e^-B_0 K)-p(1- e^-B_0 K)big) big(1-p-05(1- e^-B_0 K)+p(1- e^-B_0 K)big)Nbig( (1- e^-B_0 K )-1big)^2","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"V(hatp) =  frac025 - big(p-05big)^2 e^-2B_0 K Ne^-2B_0 K","category":"page"},{"location":"Stop/#Computer-implementation","page":"Estimation for a single qubit","title":"Computer implementation","text":"","category":"section"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"The formula mentionned above are used by the classical computer controling the quantum computer. The circuit definition and measurement is send to the quantum computer by the classical one until the stopping rule is met. At that point the quantum computer is no more required.","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"From an end-user point of view the methods are implemented using a class that takes as an input","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"A methods submitting the circuit definition and measuremnts once and returning the result in the form of an array of zeros and ones (the bits). \nThe number of bits returned must be specified as a second argument. \nA third argument is a function to be applied to the bits by the classical computer and returning a double precision number. If this argument is NULL then no function is applied. \nThe fourth argument is Delta and \nThe fifth one is the value of gamma.","category":"page"},{"location":"Stop/","page":"Estimation for a single qubit","title":"Estimation for a single qubit","text":"As a helped the user may want to know what is the expected number of runs the process may take in the worst case and some intermediary cases. A standalone program is provided where the user can provide the information and a report is produced giving some insight as to what may happen, including execution time.","category":"page"},{"location":"ToLaTeX/#Converting-a-QuantumCircuit-into-a-Quantikz/LaTeX-output","page":"Converting a QuantumCircuit into a Quantikz/LaTeX output","title":"Converting a QuantumCircuit into a Quantikz/LaTeX output","text":"","category":"section"},{"location":"ToLaTeX/","page":"Converting a QuantumCircuit into a Quantikz/LaTeX output","title":"Converting a QuantumCircuit into a Quantikz/LaTeX output","text":"The ToLaTeX function is used to produce a \\LaTeX output from either a Snowflake QuantumCircuit or a MQC (Meta Quantum Circuit). The output invokes for the Quantikz package.","category":"page"},{"location":"ToLaTeX/","page":"Converting a QuantumCircuit into a Quantikz/LaTeX output","title":"Converting a QuantumCircuit into a Quantikz/LaTeX output","text":"The output for a QuantumCircuit is a literral transcription of the circuit as displayed in Julia with the Snowflake package. It can be send to a file or display in stdout for cut&paste into a scientific document.","category":"page"},{"location":"ToLaTeX/","page":"Converting a QuantumCircuit into a Quantikz/LaTeX output","title":"Converting a QuantumCircuit into a Quantikz/LaTeX output","text":"The output for the MQC is more symbolic. Each circuit composing the MQC are displayed along all wires (qubit) used. A wire going over a circuit implies that the wire does not enter the circuit and simply cotinues to the next. If a wire enters a circuit, it is shown which qubit \"relative to the circuit\" is used.","category":"page"},{"location":"#Shovel.jl-Documentation","page":"Shovel.jl Documentation","title":"Shovel.jl Documentation","text":"","category":"section"},{"location":"","page":"Shovel.jl Documentation","title":"Shovel.jl Documentation","text":"The Shovel package contains a set of useful functions for scientists using the Qube computer.","category":"page"},{"location":"#Shootuntil-method","page":"Shovel.jl Documentation","title":"Shootuntil method","text":"","category":"section"},{"location":"","page":"Shovel.jl Documentation","title":"Shovel.jl Documentation","text":"The goal of this method is to simplify life of quantum circuit designers. Since a quantum computer is probabilistic, a circuit must be run several time in order to get a good idea of the resulting proportion of each possible measurement outcomes.","category":"page"},{"location":"","page":"Shovel.jl Documentation","title":"Shovel.jl Documentation","text":"So instead of guessing the sutable number of trial, the user of shootuntil is offered to define a confidence interval and a probability of being inside it. The function shootuntil will perform sequential shots of the circuit until it reached the desired level of confidence requested by the user.","category":"page"},{"location":"","page":"Shovel.jl Documentation","title":"Shovel.jl Documentation","text":"The user has the possibility of defining a linear combinaison of the possible outcomes. If, for instance, the probability of {0,...0} (all zeros) is desired, then the linear combinasion [1,0,...0] will be used. If, on the other hand, we seek  the probability that the last qubit is equal to 0, than, all measurements ending with zero is to be estimated. Then, the proper linear combinasion is given by [0,1,0,1,...0,1] (\"0,1\" repeated).","category":"page"},{"location":"","page":"Shovel.jl Documentation","title":"Shovel.jl Documentation","text":"# Defined in Stop.jl\r\nshootuntilresult\r\nprintshootresult\r\nshootuntil\r\n#shpush_gate!","category":"page"},{"location":"#Shovel.shootuntilresult","page":"Shovel.jl Documentation","title":"Shovel.shootuntilresult","text":"shootuntilresult is a structure containing the results of shootuntil function. It is intended to be reused by another package to perform analysis. \n\nMembers\n\ngamma::Float64 the probability that the estimated parameter is farther than Delta from the true value.\nDelta::Float64 the disired distance between estimator and true value.\ncircuit::QuantumCircuit the circuit being analysed.\nsamplesize::Int64 the resulting sample size.\nProportions::Vector{Float64} the relative frequencies of each possilble measurements of the circuit.\nfunvalue::Float64 the value of the function of the linear combinaison measured.\nvariancefun::Float64 the variance of the function of the linear combinaison.\n\nAfter running several shots of a quantum circuit using shootuntil the output is summarized into this structure and can be reused for further statistical analysis. Only the final frequency table of the shots are available since this constitute an exhaustive statistics for the results.\n\n\n\n\n\n","category":"type"},{"location":"#Shovel.printshootresult","page":"Shovel.jl Documentation","title":"Shovel.printshootresult","text":"printshootresult(io::IO, shrslt::shootuntilresult)\n\nPretty print of the shootuntilresult structure.\n\n\n\n\n\n","category":"function"},{"location":"#Shovel.shootuntil","page":"Shovel.jl Documentation","title":"Shovel.shootuntil","text":"shootuntil(fun::Function, circuit::QuantumCircuit, Δ::Float64, γ::Float64, linearcoef::Vector{Float64}, verbose::Bool=false, estimate::Bool=false, ignorefun::Bool=false)::shootuntilresult\nshootuntil(circuit::QuantumCircuit, Δ::Float64, γ::Float64, linearcoef::Vector{Float64}, verbose=false, estimate=false)::shootuntilresult\n\nRuns a circuit until there is a probability 1-γ that the precision Δ is reached for each of the state measurements.\n\nArguments\n\nfun::function : is a function you want to calculate on the resulting proportion estimate on the final state of the circuit. For instance \"sqrt\" to get |α| instead of |α|^2. The function must take a Float64 as and input and return a Float64\ncircuit::QuantumCircuit: a QuantumCircuit as defined by Snowflake\nΔ::Float64: the difference between the real value and the estimation\nγ::Float64: the probability that the estimator is more that Δ apart from the true value.\nlinearcoef::Vector{Float64}: a vector of size 2^q, where q is the number of qubit in the circuit (q=circuit.qubit_count). It is a linear combination of the probabilities of the possible bit states after measurement. For more details please see here.\nverbose::boolean: println usefull information on screen if needed for estimating suitable for Δ and γ. \nestimate::boolean : this will prevent the fuction to run past the log(1-γ)/log(1-Δ) limit which is enough to get a rough estimation of the number of shots required to reach the desired precision.\n\nThe second version  is the same but without the function.\n\nExample\n\njulia> c = QuantumCircuit(qubit_count = 3, bit_count=0);\n... ( a bunch of \"push_gate!() to define the circuit c goes here)\njulia> linear_coefficient = [1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0];\njulia> result = Shovel.shootuntil(sqrt, c, 0.001, 0.05, linear_coefficient, true);\nstarting iterative process\nMinimal number of iteration = 52\nCoefficient H(γ,Δ) = 3.8414588206941388e6\n52 iterations done. fun()=0.970725343394151\nlinear combinaison=0.9423076923076923 fun(linear combinaison)=0.970725343394151 derivative fun=0.5150788261477635\nThe estimated required number of iterations is equal to 55406\nWe need to continue\n27729 iterations done. fun()=0.9364186034730589\nlinear combinaison=0.8768798009304339 fun(linear combinaison)=0.9364186034730589 derivative fun=0.5339493250440253\nThe estimated required number of iterations is equal to 118241\n72985 iterations done. fun()=0.9355470798948244\nlinear combinaison=0.875248338699733 fun(linear combinaison)=0.9355470798948244 derivative fun=0.5344467342494053\nThe estimated required number of iterations is equal to 119808\n96396 iterations done. fun()=0.9358606183038087\nlinear combinaison=0.8758350968919872 fun(linear combinaison)=0.9358606183038087 derivative fun=0.5342676801416424\nThe estimated required number of iterations is equal to 119244\n107820 iterations done. fun()=0.9358083885129101\nlinear combinaison=0.8757373400111297 fun(linear combinaison)=0.9358083885129101 derivative fun=0.5342974989674953\nThe estimated required number of iterations is equal to 119338\n113579 iterations done. fun()=0.9357784160216117\nlinear combinaison=0.8756812438919167 fun(linear combinaison)=0.9357784160216117 derivative fun=0.534314612247011\nThe estimated required number of iterations is equal to 119392\n116485 iterations done. fun()=0.9357934167306433\nlinear combinaison=0.8757093187964116 fun(linear combinaison)=0.9357934167306433 derivative fun=0.534306047212163\nThe estimated required number of iterations is equal to 119365\n117925 iterations done. fun()=0.9358295661561952\nlinear combinaison=0.8757769768920924 fun(linear combinaison)=0.9358295661561952 derivative fun=0.5342854079098958\nThe estimated required number of iterations is equal to 119300\n119300 iterations done. fun()=0.9358466141219156\nlinear combinaison=0.8758088851634536 fun(linear combinaison)=0.9358466141219156 derivative fun=0.5342756750272848\nThe estimated required number of iterations is equal to 119269\nWe're done\n\nFinal number of iterations = 119300\n\njulia> println(result)\nγ=0.05\nΔ =0.001\nCircuit: Quantum Circuit Object:\n   id: 65e73d60-87e4-11ed-15b5-e3057c69e742\n   qubit_count: 3\n   bit_count: 0\nq[1]:--Ry(0.1)--------------------------*----*-------------------------------*--\n                                        |    |                               |\nq[2]:-------------Ry(0.2)---------------X----|---------------*----Ry(0.5)----X--\n                                             |               |\nq[3]:------------------------Ry(0.3)---------X----Ry(0.4)----X------------------\n\nNumber of shots=119300\nProportions:\n[0.804777870913663, 0.0942246437552389, 0.06854149203688181, 0.02992455993294216, 0.002321877619446773, 0.0, 0.00016764459346186087, 4.191114836546522e-5]\nEstimated value of function=0.9358466141219156\nVariance of estimate=0.031047788828476044\n\nDetails of the circuit does not matter but, since it is a 3-qubits circuit, it has 8 possible outcomes for which the relative proportions are given. The linear combinaison is such that the proportion of the first qubit being equal to 0 is used and the square root of that proportion is used for the stopping rule.\n\n\n\n\n\nshootuntil(circuit::QuantumCircuit, Δ::Float64, γ::Float64, linearcoef::Vector{Float64}, verbose=false, estimate=false)::shootuntilresult\n\nSame as above but no function is provided.\n\n\n\n\n\n","category":"function"},{"location":"#Meta-Quantum-Circuit-(shMQC)","page":"Shovel.jl Documentation","title":"Meta Quantum Circuit (shMQC)","text":"","category":"section"},{"location":"","page":"Shovel.jl Documentation","title":"Shovel.jl Documentation","text":"The idea of a meta quantum circuit is to help circuit designers to easily reuse already defined circuits. If, for instance, one has a circuit V producing a result that needs to be incerted into a larger circuit. It suffise to define how this circuit is \"plugged\" with the other elements and let shsew build the resulting circuit.","category":"page"},{"location":"","page":"Shovel.jl Documentation","title":"Shovel.jl Documentation","text":"# Defined in MQC.jl\r\nPlug\r\nConnector\r\nisinverse\r\nisbefore\r\nWire\r\nismember\r\nshprintlightQC\r\nshMQC\r\nshMQCAddCircuit\r\nshMQCAddConnector\r\nprintshMQC\r\nshsew\r\nshQuantumCircuit","category":"page"},{"location":"#Shovel.Plug","page":"Shovel.jl Documentation","title":"Shovel.Plug","text":"Plug(c::QuantumCircuit, qb::Int)\n\nMembers\n\ncircuit::QuantumCircuit\nqubit::Int a valid qubit number within the above circuit (1 ≤ qubit ≤ circuit.qubit_count)\n\nPlug is a structure containing the UUID of a Snowflake quantum circuit and a qubit number. It is the building block of a Connector. The only validation done is that the qubit number of the circuit is valid (>0 and <=qubit_count).\n\nThe comparison operator \"==\" is defined for plugs and returns true with both plugs connect the same qubits of the same circuits.\n\nExample\n\njulia> plg = Plug(c, 1)\nCircuit id: f5335690-885a-11ed-3814-393fb2ae6861   qubit: 1\n\njulia> plg2 = Plug(c,2)\nCircuit id: f5335690-885a-11ed-3814-393fb2ae6861   qubit: 2\n\njulia> plg == plg2\nfalse\n\n\n\n\n\n","category":"type"},{"location":"#Shovel.Connector","page":"Shovel.jl Documentation","title":"Shovel.Connector","text":"Connector(plg1::Plug, plg2::Plug)\nConnector(c1::QuantumCircuit, qb1::Int, c2::QuantumCircuit, qb2::Int)\n\nConnector is a structure containing two plugs: 1) the input plug which is when the qubit/circuit is coming from and 2) the output plug indicating to which qubit/circuit it is going to. Users can either create plugs and then a connector from them or directly create a connector by providing the circuit and the qubit.\n\nThe comparison operator \"==\" is defined for connectors and returns true if they have the same plugs from the same circuits IN THE SAME ORDER. If the two connectors have the same plugs but in REVERSE order, then  function isinverse should be used to check.\n\nThe two other members are used to order them within a shMQC and need not be documented at initialization time.\n\nMembers\n\nplugin::Plug the begining of the connector (circuit & qubit).\nplugout::Plug  the end of the connector (circuit & qubit).\nstage::Int not needed at construction time.\nwire::Int not needed at construction time.\n\nExample\n\nIn the example above, the connector is crated directly without the use of plugs. However, these will be created in the connector. Members \"stage\" and \"wire\" are used only within the shMQC at the final construction phase shsew\n\njulia> c1 = QuantumCircuit(qubit_count=4, bit_count=0);\n\njulia> c2 = QuantumCircuit(qubit_count=4, bit_count=0);\n\njulia> con1_1 = Connector(c1, 2, c2, 1)\nPlugin  = Circuit id: 84fbcf80-8880-11ed-354f-3dafa0e9bdc6   qubit: 2\nPlugout = Circuit id: 89614c80-8880-11ed-160b-75d0fd206f1d   qubit: 1\n\n\n\n\n\n","category":"type"},{"location":"#Shovel.isinverse","page":"Shovel.jl Documentation","title":"Shovel.isinverse","text":"isinverse(connec1::Connector, connec2::Connector)::Bool\n\nA function to checks if a given connector is the inverse of another one. The function is used for internal consistency when a connector is added to an MQC. it will return true if  \"connec1.plugin == connec2.plugout && connec1.plugin == connec2.plugout\" and false otherwise.\n\nExample\n\nAs can be seen in the example above, the second connector is define as the inverse of the first. Since a shMQC cannot contain contradictory path, this function is used to exclude this type of situation.\n\njulia> con1_1 = Connector(c1, 2, c2, 1)\nPlugin  = Circuit id: 84fbcf80-8880-11ed-354f-3dafa0e9bdc6   qubit: 2\nPlugout = Circuit id: 89614c80-8880-11ed-160b-75d0fd206f1d   qubit: 1\n\njulia> con1_2 = Connector(c2, 1, c1, 2)\nPlugin  = Circuit id: 89614c80-8880-11ed-160b-75d0fd206f1d   qubit: 1\nPlugout = Circuit id: 84fbcf80-8880-11ed-354f-3dafa0e9bdc6   qubit: 2\n\njulia> isinverse(con1_1, con1_2)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"#Shovel.isbefore","page":"Shovel.jl Documentation","title":"Shovel.isbefore","text":"isbefore(connec1::Connector, connec2::Connector)::Bool\n\nA function to checks if the output plug of connec1 is the same as the input plug of connec2. If true, it means that connec1 is just before connec2 and they are connected together in the same wire.\n\nExample\n\nThree circuits are created and connector con11 goes from c1 to c2 while con12 goes from c2 to c3. Additionally, the starting qubit of con12 is the same as the ending qubit of con11. Therefore cont11 is before con12.\n\njulia> c1 = QuantumCircuit(qubit_count=4, bit_count=0);\n\njulia> c2 = QuantumCircuit(qubit_count=4, bit_count=0);\n\njulia> c3 = QuantumCircuit(qubit_count=4, bit_count=0);\n\njulia> con1_1 = Connector(c1, 2, c2, 1)\nPlugin  = Circuit id: 71b5cfa0-8882-11ed-0999-6ff9e4725693   qubit: 2\nPlugout = Circuit id: 76869190-8882-11ed-12cd-8935492334e6   qubit: 1\n\njulia> con1_2 = Connector(c2, 1, c3, 1)\nPlugin  = Circuit id: 76869190-8882-11ed-12cd-8935492334e6   qubit: 1\nPlugout = Circuit id: 802c0d10-8882-11ed-1449-7b4ca7f5e3a1   qubit: 1\n\njulia> isbefore(con1_1, con1_2)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"#Shovel.Wire","page":"Shovel.jl Documentation","title":"Shovel.Wire","text":"Wire\n\nThe structure Wire is used to position Connectors into a shMQC. It is created while sewing the circuits together using shsew and not normally used by end users. Connectors belonging to the same wire are all connected to each other in a sequential order ( [isbefore])(@ref) is therefore true for two subsequent connectors in the connector_list. \n\nMembers\n\norder::Int in the shMQC the wires are ordered from top (=1) to buttom.\nconnector_list::Vector{Connector} is a list of Connectors composing the Wire.\n\n\n\n\n\n","category":"type"},{"location":"#Shovel.ismember","page":"Shovel.jl Documentation","title":"Shovel.ismember","text":"ismember(connec::Connector, wire::Wire)::Bool\nismember(plg::Plug, wire::Wire)::Bool\n\nChecks if a given Connector or Plug is already in a Wire. Another internal function checking if a connector is part of a given wire in a shMQC. This is an iternal fuction not needed by end users.\n\n\n\n\n\nismember(plg::Plug, wire::Wire)::Bool\n\nChecks if a plug is in a Wire. Same logic as for a connector. Internal use.\n\n\n\n\n\n","category":"function"},{"location":"#Shovel.shprintlightQC","page":"Shovel.jl Documentation","title":"Shovel.shprintlightQC","text":"shprintlightQC(io::IO, circuit::QuantumCircuit)\n\nA quick display of basic info on a QuantumCircuit. Sometime there is too much information when displaying QuantumCircuit information.\n\nExample\n\njulia> c1\nQuantum Circuit Object:\n   id: 71b5cfa0-8882-11ed-0999-6ff9e4725693\n   qubit_count: 4\n   bit_count: 0\nq[1]:──H────*────X────*───────────────────*────Z──\n            |         |                   |    |\nq[2]:───────X─────────Z──────────────*────|────|──\n                                     |    |    |\nq[3]:──────────────────────H─────────|────Z────|──\n                                     |         |\nq[4]:───────────────────────────H────Z─────────*──\n\njulia> shprintlightQC(stdout, c1)\ncircuit id: 71b5cfa0-8882-11ed-0999-6ff9e4725693  qubit_count = 4  pipeline size = 9\n\n\n\n\n\n","category":"function"},{"location":"#Shovel.shMQC","page":"Shovel.jl Documentation","title":"Shovel.shMQC","text":"The structure shMQC is the main element of the Meta Quantum Circuit utility. After adding Snowflake QuantumCircuits and Connectors to it, a quantikz/LaTeX file can be produced and, most importantly, a new circuit can be generated from the shMQC.\n\nThe main use of shMQC is to build larger circuits using alreday available circuits by plugin them together.\n\nMembers\n\ncircuit_list::Vector{QuantumCircuit}\nconnector_list::Vector{Connector}\nwire_list::Vector{Wire}\n\nThe circuitlist and connectorlist are self-explanatory. The wire_list is build by the shsew function to align all elements together.\n\n\n\n\n\n","category":"type"},{"location":"#Shovel.shMQCAddCircuit","page":"Shovel.jl Documentation","title":"Shovel.shMQCAddCircuit","text":"shMQCAddCircuit(mqc::MQC, newc::QuantumCircuit)::Bool\n\nThis function is used to add a Snowflake QuantumCircuit to a shMQC. A given circuit cannot be add twice ot the shMQC. However, two distinct circuits with identical circuitry can as long as their id is different. The function will retrun true if the addition was successful. The addition is successful is it retrurs true. Otherwise, the circuit is probably already in the shMQC.\n\nExample\n\njulia> mqc = shMQC();\njulia> shMQCAddCircuit(mqc, c1)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"#Shovel.shMQCAddConnector","page":"Shovel.jl Documentation","title":"Shovel.shMQCAddConnector","text":"shMQCAddConnector(mqc::shMQC, connec::Connector)::Bool\n\nThis function is used to add a connector to an MQC. It has several consistancy checks and will return false if the proposed connector creates inconsistencies such as circular circuitry (a list of connector looping back to the initial circuit) or duplicate Connectors.\n\nExample 1\n\nIn this example a connector is to be added but the end part of the connector was not added to the shMQC. Hece it will fail for not finding it.\n\njulia> mqc = shMQC();\njulia> shMQCAddCircuit(mqc, c1);\njulia> shMQCAddConnector(mqc, con1_1)\nAt least one circuits defined in the plugs of the connector are not in the circuit list of the shMQC. Noting to connect to\n\nExample 2\n\nNow the two end are in the shMQC\n\njulia> mqc = shMQC();\n\njulia> shMQCAddCircuit(mqc, c1);\n\njulia> shMQCAddCircuit(mqc, c2);\n\njulia> shMQCAddConnector(mqc, con1_1)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"#Shovel.printshMQC","page":"Shovel.jl Documentation","title":"Shovel.printshMQC","text":"printshMQC(io::IO, mqc::shMQC)\n\nSummary print of what's inside a shMQC.\n\nExample\n\nIn the example abva, 5 circuits are added into a shMQC, using shMQCAddCircuit, and several connectors, using [shMQCAddConnector]@(ref)  defining the piping of the shMQC.\n\njulia> mqc = shMQC();\njulia> shMQCAddCircuit(mqc, c1);\njulia> shMQCAddCircuit(mqc, c2);\njulia> shMQCAddCircuit(mqc, c3);\njulia> shMQCAddCircuit(mqc, c4);\njulia> shMQCAddCircuit(mqc, c5);\njulia> shMQCAddConnector(mqc, con1_1);\njulia> shMQCAddConnector(mqc, con1_2);\njulia> shMQCAddConnector(mqc, con1_3);\njulia> shMQCAddConnector(mqc, con2_1);\njulia> shMQCAddConnector(mqc, con2_2);\njulia> shMQCAddConnector(mqc, con2_3);\njulia> shMQCAddConnector(mqc, con3_1);\njulia> shMQCAddConnector(mqc, con3_2);\njulia> shMQCAddConnector(mqc, con3_3);\njulia> shMQCAddConnector(mqc, con4_1);\njulia> shMQCAddConnector(mqc, con4_2);\njulia> shMQCAddConnector(mqc, con4_3);\n\njulia> mqc\nThe shMQC is made of these circuits:\ncircuit id: 24a8c970-8886-11ed-3438-9f8d7f11f419  qubit_count = 4  pipeline size = 9\ncircuit id: 24b68510-8886-11ed-211f-c9940c38b4a6  qubit_count = 4  pipeline size = 9\ncircuit id: 24c48ed0-8886-11ed-3ef0-994877b2a905  qubit_count = 4  pipeline size = 9\ncircuit id: 24d61b00-8886-11ed-1cc7-173c101871b8  qubit_count = 4  pipeline size = 9\ncircuit id: 24def4a0-8886-11ed-15e9-d90899ad2133  qubit_count = 6  pipeline size = 14\n\nAnd these connector\nConnector 1\nPlugin  = Circuit id: 24a8c970-8886-11ed-3438-9f8d7f11f419   qubit: 2\nPlugout = Circuit id: 24b68510-8886-11ed-211f-c9940c38b4a6   qubit: 1\nConnector 2\nPlugin  = Circuit id: 24a8c970-8886-11ed-3438-9f8d7f11f419   qubit: 3\nPlugout = Circuit id: 24b68510-8886-11ed-211f-c9940c38b4a6   qubit: 2\nConnector 3\nPlugin  = Circuit id: 24a8c970-8886-11ed-3438-9f8d7f11f419   qubit: 4\nPlugout = Circuit id: 24b68510-8886-11ed-211f-c9940c38b4a6   qubit: 3\nConnector 4\nPlugin  = Circuit id: 24b68510-8886-11ed-211f-c9940c38b4a6   qubit: 2\nPlugout = Circuit id: 24c48ed0-8886-11ed-3ef0-994877b2a905   qubit: 1\nConnector 5\nPlugin  = Circuit id: 24b68510-8886-11ed-211f-c9940c38b4a6   qubit: 3\nPlugout = Circuit id: 24c48ed0-8886-11ed-3ef0-994877b2a905   qubit: 2\nConnector 6\nPlugin  = Circuit id: 24b68510-8886-11ed-211f-c9940c38b4a6   qubit: 4\nPlugout = Circuit id: 24c48ed0-8886-11ed-3ef0-994877b2a905   qubit: 3\nConnector 7\nPlugin  = Circuit id: 24c48ed0-8886-11ed-3ef0-994877b2a905   qubit: 2\nPlugout = Circuit id: 24d61b00-8886-11ed-1cc7-173c101871b8   qubit: 1\nConnector 8\nPlugin  = Circuit id: 24c48ed0-8886-11ed-3ef0-994877b2a905   qubit: 3\nPlugout = Circuit id: 24d61b00-8886-11ed-1cc7-173c101871b8   qubit: 2\nConnector 9\nPlugin  = Circuit id: 24c48ed0-8886-11ed-3ef0-994877b2a905   qubit: 4\nPlugout = Circuit id: 24d61b00-8886-11ed-1cc7-173c101871b8   qubit: 3\nConnector 10\nPlugin  = Circuit id: 24d61b00-8886-11ed-1cc7-173c101871b8   qubit: 1\nPlugout = Circuit id: 24def4a0-8886-11ed-15e9-d90899ad2133   qubit: 3\nConnector 11\nPlugin  = Circuit id: 24d61b00-8886-11ed-1cc7-173c101871b8   qubit: 3\nPlugout = Circuit id: 24def4a0-8886-11ed-15e9-d90899ad2133   qubit: 2\nConnector 12\nPlugin  = Circuit id: 24d61b00-8886-11ed-1cc7-173c101871b8   qubit: 4\nPlugout = Circuit id: 24def4a0-8886-11ed-15e9-d90899ad2133   qubit: 5\n\n\n\n\n\n","category":"function"},{"location":"#Shovel.shsew","page":"Shovel.jl Documentation","title":"Shovel.shsew","text":"shsew(mqc::shMQC)::QuantumCircuit\n\nThis function takes an shMQC and returns a standard Snowflake QuantumCircuit equivalent. This is the main goal of the shMQC concept.\n\nExample\n\nA shMQC is created with 5 circuits and 12 connectors. The resulting quantum circuit is then created by sewing all pieces together.\n\njulia> mqc\n\nThe shMQC is made of these circuits:\ncircuit id: 9c9b32e0-8888-11ed-0a20-f12af1106257  qubit_count = 4  pipeline size = 9\ncircuit id: 9ca6cba0-8888-11ed-375f-ef0c51f31fc8  qubit_count = 4  pipeline size = 9\ncircuit id: 9cb39ce0-8888-11ed-05d5-bff313ab1874  qubit_count = 4  pipeline size = 9\ncircuit id: 9cc3062e-8888-11ed-2d41-45f511d1ab58  qubit_count = 4  pipeline size = 9\ncircuit id: 9ccb6aa0-8888-11ed-02ee-d37c6c44d379  qubit_count = 6  pipeline size = 14\n\nAnd these connector\nConnector 1\nPlugin  = Circuit id: 9c9b32e0-8888-11ed-0a20-f12af1106257   qubit: 2\nPlugout = Circuit id: 9ca6cba0-8888-11ed-375f-ef0c51f31fc8   qubit: 1\nConnector 2\nPlugin  = Circuit id: 9c9b32e0-8888-11ed-0a20-f12af1106257   qubit: 3\nPlugout = Circuit id: 9ca6cba0-8888-11ed-375f-ef0c51f31fc8   qubit: 2\nConnector 3\nPlugin  = Circuit id: 9c9b32e0-8888-11ed-0a20-f12af1106257   qubit: 4\nPlugout = Circuit id: 9ca6cba0-8888-11ed-375f-ef0c51f31fc8   qubit: 3\nConnector 4\nPlugin  = Circuit id: 9ca6cba0-8888-11ed-375f-ef0c51f31fc8   qubit: 2\nPlugout = Circuit id: 9cb39ce0-8888-11ed-05d5-bff313ab1874   qubit: 1\nConnector 5\nPlugin  = Circuit id: 9ca6cba0-8888-11ed-375f-ef0c51f31fc8   qubit: 3\nPlugout = Circuit id: 9cb39ce0-8888-11ed-05d5-bff313ab1874   qubit: 2\nConnector 6\nPlugin  = Circuit id: 9ca6cba0-8888-11ed-375f-ef0c51f31fc8   qubit: 4\nPlugout = Circuit id: 9cb39ce0-8888-11ed-05d5-bff313ab1874   qubit: 3\nConnector 7\nPlugin  = Circuit id: 9cb39ce0-8888-11ed-05d5-bff313ab1874   qubit: 2\nPlugout = Circuit id: 9cc3062e-8888-11ed-2d41-45f511d1ab58   qubit: 1\nConnector 8\nPlugin  = Circuit id: 9cb39ce0-8888-11ed-05d5-bff313ab1874   qubit: 3\nPlugout = Circuit id: 9cc3062e-8888-11ed-2d41-45f511d1ab58   qubit: 2\nConnector 9\nPlugin  = Circuit id: 9cb39ce0-8888-11ed-05d5-bff313ab1874   qubit: 4\nPlugout = Circuit id: 9cc3062e-8888-11ed-2d41-45f511d1ab58   qubit: 3\nConnector 10\nPlugin  = Circuit id: 9cc3062e-8888-11ed-2d41-45f511d1ab58   qubit: 1\nPlugout = Circuit id: 9ccb6aa0-8888-11ed-02ee-d37c6c44d379   qubit: 3\nConnector 11\nPlugin  = Circuit id: 9cc3062e-8888-11ed-2d41-45f511d1ab58   qubit: 3\nPlugout = Circuit id: 9ccb6aa0-8888-11ed-02ee-d37c6c44d379   qubit: 2\nConnector 12\nPlugin  = Circuit id: 9cc3062e-8888-11ed-2d41-45f511d1ab58   qubit: 4\nPlugout = Circuit id: 9ccb6aa0-8888-11ed-02ee-d37c6c44d379   qubit: 5\n\njulia> newcq = shsew(mqc)\nQuantum Circuit Object:\n   id: ac5ded7e-8888-11ed-3316-75f366b5ec40\n   qubit_count: 10\n   bit_count: 0\nPart 1 of 2\nq[1]: ──H────*────X────*───────────────────*────Z─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n             |         |                   |    |\nq[2]: ───────X─────────Z──────────────*────|────|────H────*────X────*───────────────────*────Z────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n                                      |    |    |         |         |                   |    |\nq[3]: ──────────────────────H─────────|────Z────|─────────X─────────Z──────────────*────|────|────H────*────X────*───────────────────*────Z───────────────────────────────────────────────────────────────────\n                                      |         |                                  |    |    |         |         |                   |    |\nq[4]: ───────────────────────────H────Z─────────*────────────────────────H─────────|────Z────|─────────X─────────Z──────────────*────|────|────H────*────X────*───────────────────*────Z──────────────────────\n                                                                                   |         |                                  |    |    |         |         |                   |    |\nq[5]: ────────────────────────────────────────────────────────────────────────H────Z─────────*────────────────────────H─────────|────Z────|─────────X─────────Z──────────────*────|────|──────────────────────\n                                                                                                                                |         |                                  |    |    |\nq[6]: ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────H────Z─────────*────────────────────────H─────────|────Z────|───────────────────X──\n                                                                                                                                                                             |         |                   |  \nq[7]: ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────H────Z─────────*─────────H─────────|──\n                                                                                                                                                                                                           |\nq[8]: ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────H──────────────*──\n\nq[9]: ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n\nq[10]:────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────H───────\n\n\nPart 2 of 2\nq[1]: ──────────────────────────────────────────────────\n\nq[2]: ──────────────────────────────────────────────────\n\nq[3]: ──────────────────────────────────────────────────\n\nq[4]: ────────────H──────────────Z─────────X────────────\n                                 |         |\nq[5]: ───────────────────────────|─────────|────────────\n                                 |         |\nq[6]: ───────Z──────────────*────|─────────|─────────*──\n             |              |    |         |         |\nq[7]: ───────|──────────────|────|─────────*─────────|──\n             |              |    |                   |\nq[8]: ──X────*──────────────|────*────Z──────────────|──\n                            |         |              |\nq[9]: ─────────────────H────Z─────────*─────────X────|──\n                                                |    |\nq[10]:──────────────────────────────────────────*────X──\n\n\n\n\n\n","category":"function"},{"location":"#Shovel.shQuantumCircuit","page":"Shovel.jl Documentation","title":"Shovel.shQuantumCircuit","text":"shQuantumCircuit\n\nshQuantumCircuit is a structure holding additional descriptive information for rgw Quantum circuits such as a label for circuits and angle  information for rotation gates Rx, Ry, R_y and the generic rotation gate.\n\n\n\n\n\n","category":"type"},{"location":"#LaTeX-utilities","page":"Shovel.jl Documentation","title":"LaTeX utilities","text":"","category":"section"},{"location":"","page":"Shovel.jl Documentation","title":"Shovel.jl Documentation","text":"Snowflake aloows to display a circuit on the screen. However, for scientific resaerch or educational purpose, it is often required to produce a LaTeX document. These utilities allow for a conversion of either a Snowflake circuit or a shMQC into Quantikz/Latex format.","category":"page"},{"location":"","page":"Shovel.jl Documentation","title":"Shovel.jl Documentation","text":"Additionally, it is also possible to display the resulting operator of a circuit into textual forme. The resulting string matrix is often very large and difficult to read but elements of it can be inspected to better understand what is going on. This is usefull only on relatively small circuits and is of educational interest for beginners.","category":"page"},{"location":"","page":"Shovel.jl Documentation","title":"Shovel.jl Documentation","text":"# Defined in ToLaTeX.jl\r\nshLaTeX\r\nshstrmult\r\nshmult\r\nshkron\r\nshrx\r\nshry\r\nshr\r\nshhadamard\r\nshid\r\nshcnot\r\nshcnot1\r\nshoperator","category":"page"},{"location":"#Shovel.shLaTeX","page":"Shovel.jl Documentation","title":"Shovel.shLaTeX","text":"shLaTeX(pattern::String, str::String)::String\n\nThis function will substitute \"pattern\" inside str by \"\\pattern\". This is mostly used when pattern = sin, cos or sqrt. It is used in the process of formatting states and operator in string format as  generated by shoperator\n\nIn the example below, all occurence of the string \"cos\" are replaced by \"\\cos\".\n\nExample\n\njulia> text = \"1/sqrt{2}cos(1.2/2)+1/sqrt{2}-sin(1.2/2)cos(0.69/2)cos(1.99/2)+1/sqrt{2}cos(1.2/2)+1/sqrt{2}-sin(1.2/2)sin(0.69/2)-sin(1.99/2)cos(1.99/2)+1/sqrt{2}cos(1.2/2)+1/sqrt{2}\";\njulia> shLaTeX(\"cos\", text)\n\"1/sqrt{2}\\cos(1.2/2)+1/sqrt{2}-sin(1.2/2)\\cos(0.69/2)\\cos(1.99/2)+1/sqrt{2}\\cos(1.2/2)+1/sqrt{2}-sin(1.2/2)sin(0.69/2)-sin(1.99/2)\\cos(1.99/2)+1/sqrt{2}\\cos(1.2/2)+1/sqrt{2}\"\n\n\n\n\n\nshLaTeX(str::String)::String\n\nThis function will substitute \"cos\" by \"\\cos\", \"sin\" by \"\\sin\" and \"sqrt\" by \"\\sqrt\" in str.\n\nExample\n\njulia> text = \"1/sqrt{2}cos(1.2/2)+1/sqrt{2}-sin(1.2/2)cos(0.69/2)cos(1.99/2)+1/sqrt{2}cos(1.2/2)+1/sqrt{2}-sin(1.2/2)sin(0.69/2)-sin(1.99/2)cos(1.99/2)+1/sqrt{2}cos(1.2/2)+1/sqrt{2}\"\njulia> shLaTeX(text)\n\"1/\\sqrt{2}\\cos(1.2/2)+1/\\sqrt{2}-\\sin(1.2/2)\\cos(0.69/2)\\cos(1.99/2)+1/\\sqrt{2}\\cos(1.2/2)+1/\\sqrt{2}-\\sin(1.2/2)\\sin(0.69/2)-\\sin(1.99/2)\\cos(1.99/2)+1/\\sqrt{2}\\cos(1.2/2)+1/\\sqrt{2}\"\n\n\n\n\n\nshLaTeX(c::QuantumCircuit, FName::String)::Bool\n\nWill generate a file containing the LaTeX/quantikz code in the standalone documentclass.\n\nArguments\n\ncircuit::QuantumCircuit: a QuantumCircuit as defined by Snowflake\nFName::String: the name of the file to create. Warning! It will overwrite if already existing. If omitted it will print to stdout\n\nExample\n\njulia> c = QuantumCircuit(qubit_count=3, bit_count=0);\n... (a bunch of \"push_gate!\" goes here)\njulia> shLaTeX(c);\n\\begin{quantikz}\n\\lstick{q[1]: } & \\gate{H} & \\gate{Ry(1.2)} & \\qw & \\ctrl{1} & \\ctrl{2} & \\ctrl{1} & \\qw & \\ctrl{1} & \\ctrl{2} & \\qw & \\qw & \\qw \\\\\n\\lstick{q[2]: } & \\qw & \\qw & \\qw & \\gate{X} & \\qw & \\gate{X} & \\qw & \\gate{X} & \\qw & \\qw & \\gate{Rx(-0.29)} & \\qw \\\\\n\\lstick{q[3]: } & \\qw & \\qw & \\gate{Rx(0.69)} & \\qw & \\gate{X} & \\qw & \\gate{Ry(1.99)} & \\qw & \\gate{X} & \\gate{Ry(1.99)} & \\qw & \\qw\n\\end{quantikz}\n\nThis is an example of the output file generated by shLaTeX(). It can be copy&paste to any other Latex document.\n\n\\documentclass{standalone}\n\\usepackage{tikz}\n\\usetikzlibrary{quantikz}\n\\begin{document}\n\n\\begin{quantikz}\n\\lstick{q[1]: } & \\gate{H} & \\gate{Ry(1.2)} & \\qw & \\ctrl{1} & \\ctrl{2} & \\ctrl{1} & \\qw & \\ctrl{1} & \\ctrl{2} & \\qw & \\qw & \\qw \\\\ \n\\lstick{q[2]: } & \\qw & \\qw & \\qw & \\gate{X} & \\qw & \\gate{X} & \\qw & \\gate{X} & \\qw & \\qw & \\gate{Rx(-0.29)} & \\qw \\\\ \n\\lstick{q[3]: } & \\qw & \\qw & \\gate{Rx(0.69)} & \\qw & \\gate{X} & \\qw & \\gate{Ry(1.99)} & \\qw & \\gate{X} & \\gate{Ry(1.99)} & \\qw & \\qw\n\\end{quantikz}\n\\end{document}\n\n\n\n\n\nshLaTeX(mat::Matrix{String})\n\nWill convert to LaTeX the operator matrix generated by shoperator  A garder??? In the example above a Kroneker product of a CNOT circuit by an Hadamard circuit (both in \"string\" version) is generated. The function shLaTeX is then used to produce the LaTeX version of it.\n\njulia> mat2 = shcnot(1,2,2);\njulia> mat3 = shhadamard();\njulia> mat4 = shkron(mat3,mat2)\n8×8 Matrix{String}:\n \"1/sqrt{2}\"  \"0\"          \"0\"          \"0\"          \"1/sqrt{2}\"   \"0\"           \"0\"           \"0\"\n \"0\"          \"1/sqrt{2}\"  \"0\"          \"0\"          \"0\"           \"1/sqrt{2}\"   \"0\"           \"0\"\n \"0\"          \"0\"          \"0\"          \"1/sqrt{2}\"  \"0\"           \"0\"           \"0\"           \"1/sqrt{2}\"\n \"0\"          \"0\"          \"1/sqrt{2}\"  \"0\"          \"0\"           \"0\"           \"1/sqrt{2}\"   \"0\"\n \"1/sqrt{2}\"  \"0\"          \"0\"          \"0\"          \"-1/sqrt{2}\"  \"0\"           \"0\"           \"0\"\n \"0\"          \"1/sqrt{2}\"  \"0\"          \"0\"          \"0\"           \"-1/sqrt{2}\"  \"0\"           \"0\"\n \"0\"          \"0\"          \"0\"          \"1/sqrt{2}\"  \"0\"           \"0\"           \"0\"           \"-1/sqrt{2}\"\n \"0\"          \"0\"          \"1/sqrt{2}\"  \"0\"          \"0\"           \"0\"           \"-1/sqrt{2}\"  \"0\"\n julia> shLaTeX(mat4)\n \\begin{bmatrix}\n 1/\\sqrt{2} &0 &0 &0 &1/\\sqrt{2} &0 &0 &0 \\\\\n 0 &1/\\sqrt{2} &0 &0 &0 &1/\\sqrt{2} &0 &0 \\\\\n 0 &0 &0 &1/\\sqrt{2} &0 &0 &0 &1/\\sqrt{2} \\\\\n 0 &0 &1/\\sqrt{2} &0 &0 &0 &1/\\sqrt{2} &0 \\\\\n 1/\\sqrt{2} &0 &0 &0 &-1/\\sqrt{2} &0 &0 &0 \\\\\n 0 &1/\\sqrt{2} &0 &0 &0 &-1/\\sqrt{2} &0 &0 \\\\\n 0 &0 &0 &1/\\sqrt{2} &0 &0 &0 &-1/\\sqrt{2} \\\\\n 0 &0 &1/\\sqrt{2} &0 &0 &0 &-1/\\sqrt{2} &0 \\\\\n \\end{bmatrix}\n\n\n\n\n\nshLaTeX(mqc::shMQC, FName = \"\")::Bool\n\nArguments\n\nmqc::shMQC: a Meta Quantum Circuit as defined by Shovel\nFName::String: the name of the file to create. Warning! It will overwrite if already existing. If omitted it will print to stdout\n\nA shMQC is usually large and only used as an intermediate step before being transformed into a Snowflake QuantumCircuit. It is nevertheless possible to produce a meaningful LaTeX output that can be analysed for troubleshooting.\n\nExample\n\njulia> shLaTeX(mqc, \"Foo.bar\")\n\n\n\n\n\n","category":"function"},{"location":"#Shovel.shstrmult","page":"Shovel.jl Documentation","title":"Shovel.shstrmult","text":"shstrmult(s1::String, s2::String)::String will lexicographically multiply (concatenate) two strings.\n\nThe concatenation will follow the following rules: shstrmult(\"0\", \"a string\") => \"0\" shstrmult(\"1\", \"a string\") => \"a string\" shstrmult(\"a string\", \"0\") => \"0\" shstrmult(\"a string\", \"1\") => \"a string\" Otherwise shstrmult(\"a string\", \"-a second string\") => \"a string-a second string\"\n\nThe arithmetic defined by shstrmult is at the base of the arithmetic of matric multiplication shmult and Kroneker product shkron of string matrix for operators.\n\njulia> a = \"0\" ; b= \"a string\";\n\njulia> shstrmult(a,b)\n\"0\"\n\njulia> c = \"1\";\n\njulia> shstrmult(c,b)\n\"a string\"\n\njulia> shstrmult(c,a)\n\"0\"\n\n\n\n\n\n","category":"function"},{"location":"#Shovel.shmult","page":"Shovel.jl Documentation","title":"Shovel.shmult","text":"shmult(mat1::Matrix{String}, mat2::Matrix{String})::Matrix{String} will perform the lexicographic multiplication of two string matrices. It is based on the rules for function shstrmult()\n\nThis will perform the matrix multiplication mat1 × mat2 using String matrices using the same rules as shstrmult.\n\nParameters\n\nmat1 and mat2 have to satisfy size(mat1)[2] == size(mat2)[1]\n\nThe return matrix will have size (size(mat1)[1], size(mat2)[2])\n\nExample 1\n\njulia> A = [ \"a\" \"b\" ; \"c\" \"d\" ];\n\njulia> B = [ \"e\" \"f\" ; \"g\" \"h\" ; \"i\" \"j\" ];\n\njulia> C = shmult(B, A)\n3×2 Matrix{String}:\n \"ea+fc\"  \"eb+fd\"\n \"ga+hc\"  \"gb+hd\"\n \"ia+jc\"  \"ib+jd\"\n\nExample 2\n\njulia> A = [ \"1\" \"b\" ; \"c\" \"0\" ];\n\njulia> B = [ \"e\" \"f\" ; \"g\" \"h\" ; \"i\" \"j\" ];\n\njulia> C = shmult(B, A)\n3×2 Matrix{String}:\n \"e+fc\"  \"eb\"\n \"g+hc\"  \"gb\"\n \"i+jc\"  \"ib\"\n\nAs can be seen in the second example, the fact that A[1,1] = \"1\" makes it irrelevant and it is simply remove ( \"1\" * \"anystring\" = \"anystring\").  Hereas, A[2,2] = \"0\" which implies that and multiplycation results into \"0\" and will be removed unless it is alone (\"0\" + \"anystring\" = \"anystring\", but \"0\" + nothing = \"0\")\n\n\n\n\n\n","category":"function"},{"location":"#Shovel.shkron","page":"Shovel.jl Documentation","title":"Shovel.shkron","text":"shkron(mat1::Matrix{String}, mat2::Matrix{String})::Matrix{String} will perform the lexicographic Kroneker product of two matrices.\n\nKroneker product of two string matrices. Here again, the logic of shstrmult is used to remove unneeded \"0\" and \"1\"\n\nExample 1\n\njulia> A = [ \"a\" \"b\" ; \"c\" \"d\" ];\n\njulia> B = [ \"e\" \"f\" ; \"g\" \"h\" ; \"i\" \"j\" ];\n\njulia> C = shkron(B, A)\n6×4 Matrix{String}:\n \"ea\"  \"eb\"  \"fa\"  \"fb\"\n \"ec\"  \"ed\"  \"fc\"  \"fd\"\n \"ga\"  \"gb\"  \"ha\"  \"hb\"\n \"gc\"  \"gd\"  \"hc\"  \"hd\"\n \"ia\"  \"ib\"  \"ja\"  \"jb\"\n \"ic\"  \"id\"  \"jc\"  \"jd\"\n\nExample 2\n\nIn this second example a value of B is equal to \"0\" and another is equal to \"1\".\n\njulia> A = [ \"a\" \"b\" ; \"c\" \"d\" ];\n\njulia> B = [ \"e\" \"0\" ; \"1\" \"h\" ; \"i\" \"j\" ];\n\njulia> C = shkron(B, A)\n6×4 Matrix{String}:\n \"ea\"  \"eb\"  \"0\"   \"0\"\n \"ec\"  \"ed\"  \"0\"   \"0\"\n \"a\"   \"b\"   \"ha\"  \"hb\"\n \"c\"   \"d\"   \"hc\"  \"hd\"\n \"ia\"  \"ib\"  \"ja\"  \"jb\"\n \"ic\"  \"id\"  \"jc\"  \"jd\"\n\n\n\n\n\n","category":"function"},{"location":"#Shovel.shrx","page":"Shovel.jl Documentation","title":"Shovel.shrx","text":"shrx(gate::Gate)::Matrix{String}\n\nReturns the string expression of the operator of gate doing a rotation around the X axis using the information provided in a Gate (gate.parameters[1]).\n\nExample\n\njulia> gate = rotation_x(2, 0.20)\nGate Object:\ninstruction symbol: rx\nparameters: [0.2]\ntargets: [2]\noperator:\n(2, 2)-element Snowflake.Operator:\nUnderlying data Matrix{Complex}:\n0.9950041652780258 + 0.0im    0.0 - 0.09983341664682815im\n0.0 - 0.09983341664682815im    0.9950041652780258 + 0.0im\n\njulia> shrx(gate)\n2×2 Matrix{String}:\n \"cos(0.2/2)\"   \"sin(0.2/2)\"\n \"sin(0.2/2)i\"  \"cos(0.2/2)\"\n\n\n\n\n\n","category":"function"},{"location":"#Shovel.shry","page":"Shovel.jl Documentation","title":"Shovel.shry","text":"shry(gate::Gate)::Matrix{String}\n\nReturns the Latex expression of the operator of gate doing a rotation around the Y axis using the information provided in a Gate (gate.parameters[1]).\n\nExample\n\njulia> gate = rotation_y(1, 1.3)\nGate Object:\ninstruction symbol: ry\nparameters: [1.3]\ntargets: [1]\noperator:\n(2, 2)-element Snowflake.Operator:\nUnderlying data Matrix{Complex}:\n0.7960837985490558 + 0.0im    -0.6051864057360395 - 3.705697973360661e-17im\n0.6051864057360395 - 3.705697973360661e-17im    0.7960837985490558 + 0.0im\n\n\njulia> shry(gate)\n2×2 Matrix{String}:\n \"cos(1.3/2)\"   \"sin(1.3/2)\"\n \"-sin(1.3/2)\"  \"cos(1.3/2)\"\n\n\n\n\n\n","category":"function"},{"location":"#Shovel.shr","page":"Shovel.jl Documentation","title":"Shovel.shr","text":"shr(gate::Gate)::Matrix{String}\n\nReturns the Latex expression of the operator of gate doing a rotation with θ and ϕ axis using the information provided in shcircuits.\n\nExample\n\njulia> gate = rotation(1, 1.9, 2.1)\nGate Object:\ninstruction symbol: r\nparameters: [1.9, 2.1]\ntargets: [1]\noperator:\n(2, 2)-element Snowflake.Operator:\nUnderlying data Matrix{Complex}:\n0.5816830894638835 + 0.0im    -0.7021478827116092 + 0.4106496490140421im\n0.7021478827116092 + 0.4106496490140421im    0.5816830894638835 + 0.0im\n\n\njulia> shr(gate)\n2×2 Matrix{String}:\n \"cos(1.9/2}\"            \"-ie^{-i2.1}sin(1.9/2)\"\n \"-ie^{i2.1}sin(1.9/2)\"  \"cos(1.9/2}\"\n\n\n\n\n\n","category":"function"},{"location":"#Shovel.shhadamard","page":"Shovel.jl Documentation","title":"Shovel.shhadamard","text":"shry(gate::Gate)::Matrix{String}\n\nReturns the Latex expression of the operator of a Hadamard gate no information needs to be provided in shcircuits for that type of circuit.\n\nExample\n\njulia> shhadamard()\n2×2 Matrix{String}:\n \"1/sqrt{2}\"  \"1/sqrt{2}\"\n \"1/sqrt{2}\"  \"-1/sqrt{2}\"\n\n\n\n\n\n","category":"function"},{"location":"#Shovel.shid","page":"Shovel.jl Documentation","title":"Shovel.shid","text":"shid()()::Matrix{String}\n\nReturns a simple identity matrix in string format.\n\nExample\n\njulia> shid()\n2×2 Matrix{String}:\n \"1\"  \"0\"\n \"0\"  \"1\"\n\n\n\n\n\nshid(N::Int)::Matrix{String}\n\nReturns the 2^N X 2^N identity matrix in string format.\n\nExample\n\njulia> shid(3)\n8×8 Matrix{String}:\n \"1\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"\n \"0\"  \"1\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"\n \"0\"  \"0\"  \"1\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"\n \"0\"  \"0\"  \"0\"  \"1\"  \"0\"  \"0\"  \"0\"  \"0\"\n \"0\"  \"0\"  \"0\"  \"0\"  \"1\"  \"0\"  \"0\"  \"0\"\n \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"1\"  \"0\"  \"0\"\n \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"1\"  \"0\"\n \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"1\"\n\n\n\n\n\n","category":"function"},{"location":"#Shovel.shcnot","page":"Shovel.jl Documentation","title":"Shovel.shcnot","text":"shcnot()::Matrix{String}\n\nReturns the 4x4 CNOT matrix in string format.\n\nExample\n\njulia> shcnot()\n4×4 Matrix{String}:\n \"1\"  \"0\"  \"0\"  \"0\"\n \"0\"  \"1\"  \"0\"  \"0\"\n \"0\"  \"0\"  \"0\"  \"1\"\n \"0\"  \"0\"  \"1\"  \"0\"\n\n\n\n\n\nshcnot(crtl::Int, trgt::Int, N::Int)::Matrix{String}\n\nReturns, in string format, the CNOT matrix for a set of N qubits where the control qubit is at position crtl and the target is at position trgt wit (trgt>crtl).\n\nExample\n\njulia> shcnot(2,4,4)\n16×16 Matrix{String}:\n \"1\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"\n \"0\"  \"1\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"\n \"0\"  \"0\"  \"1\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"\n \"0\"  \"0\"  \"0\"  \"1\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"\n \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"1\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"\n \"0\"  \"0\"  \"0\"  \"0\"  \"1\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"\n \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"1\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"\n \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"1\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"\n \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"1\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"\n \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"1\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"\n \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"1\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"\n \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"1\"  \"0\"  \"0\"  \"0\"  \"0\"\n \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"1\"  \"0\"  \"0\"\n \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"1\"  \"0\"  \"0\"  \"0\"\n \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"1\"\n \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"1\"  \"0\"\n\n\n\n\n\n","category":"function"},{"location":"#Shovel.shcnot1","page":"Shovel.jl Documentation","title":"Shovel.shcnot1","text":"shcnot1(crtl::Int, N::Int)::Matrix{String}\n\nThis function returns, in string format, the CNOT matrix for a set of N qubits when the control qubit is at position ctrl (ctrl < (N-1)) and the target qubit is right under it (crtl+1). BEWARE! It is assumed here that the control qubit is over the target.\n\nExample\n\njulia> shcnot1(2, 3)\n8×8 Matrix{String}:\n \"1\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"\n \"0\"  \"1\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"\n \"0\"  \"0\"  \"0\"  \"1\"  \"0\"  \"0\"  \"0\"  \"0\"\n \"0\"  \"0\"  \"1\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"\n \"0\"  \"0\"  \"0\"  \"0\"  \"1\"  \"0\"  \"0\"  \"0\"\n \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"1\"  \"0\"  \"0\"\n \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"1\"\n \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"0\"  \"1\"  \"0\"\n\n\n\n\n\n","category":"function"},{"location":"#Shovel.shoperator","page":"Shovel.jl Documentation","title":"Shovel.shoperator","text":"shoperator(c::QuantumCircuit)::Matrix{String}\n\nReturns, in string format, the resulting operator of a quantum circuit.\n\nThis can give a fairly large matrix difficult to read. However each individual element of it can be displayed, as in the example above to see what is happeneing in the operator.\n\nExample\n\njulia> c = QuantumCircuit(qubit_count=3, bit_count=0);\njulia> push_gate!(c, hadamard(1));\njulia> push_gate!(c, rotation_y(1, 1.2));\njulia> push_gate!(c, rotation_x(3, 0.69));\njulia> push_gate!(c, control_x(1,2));\njulia> push_gate!(c, control_x(1,3));\njulia> push_gate!(c, control_x(1,2));\njulia> push_gate!(c, rotation_y(3, 1.99));\njulia> push_gate!(c, control_x(1,2));\njulia> push_gate!(c, control_x(1,3));\njulia> push_gate!(c, rotation_y(3, 1.99));\njulia> push_gate!(c, rotation_x(2, -0.29));\n\njulia> mat = shoperator(c)\n8×8 Matrix{String}:\n \"1/sqrt{2}cos(1.2/2)+1/sqrt{2}-s\" ⋯ 226 bytes ⋯ \".99/2)-sin(1.99/2)cos(-0.29/2)\"         …  \"1/sqrt{2}sin(1.2/2)+1/sqrt{2}co\" ⋯ 221 bytes ⋯ \"1.99/2)cos(1.99/2)cos(-0.29/2)\"\n \"1/sqrt{2}cos(1.2/2)+1/sqrt{2}-s\" ⋯ 228 bytes ⋯ \".99/2)-sin(1.99/2)cos(-0.29/2)\"          \"1/sqrt{2}sin(1.2/2)+1/sqrt{2}co\" ⋯ 223 bytes ⋯ \"1.99/2)cos(1.99/2)cos(-0.29/2)\"\n \"1/sqrt{2}cos(1.2/2)+1/sqrt{2}-s\" ⋯ 227 bytes ⋯ \"99/2)-sin(1.99/2)sin(-0.29/2)i\"           \"1/sqrt{2}sin(1.2/2)+1/sqrt{2}co\" ⋯ 221 bytes ⋯ \"1.99/2)cos(1.99/2)sin(-0.29/2)\"\n \"1/sqrt{2}cos(1.2/2)+1/sqrt{2}-s\" ⋯ 229 bytes ⋯ \"99/2)-sin(1.99/2)sin(-0.29/2)i\"         \"1/sqrt{2}sin(1.2/2)+1/sqrt{2}co\" ⋯ 223 bytes ⋯ \"1.99/2)cos(1.99/2)sin(-0.29/2)\"\n \"1/sqrt{2}cos(1.2/2)+-1/sqrt{2}-\" ⋯ 230 bytes ⋯ \".99/2)-sin(1.99/2)cos(-0.29/2)\"        \"1/sqrt{2}sin(1.2/2)+-1/sqrt{2}c\" ⋯ 225 bytes ⋯ \"1.99/2)cos(1.99/2)cos(-0.29/2)\"\n \"1/sqrt{2}cos(1.2/2)+-1/sqrt{2}-\" ⋯ 232 bytes ⋯ \".99/2)-sin(1.99/2)cos(-0.29/2)\"   …  \"1/sqrt{2}sin(1.2/2)+-1/sqrt{2}c\" ⋯ 227 bytes ⋯ \"1.99/2)cos(1.99/2)cos(-0.29/2)\"\n \"1/sqrt{2}cos(1.2/2)+-1/sqrt{2}-\" ⋯ 231 bytes ⋯ \"99/2)-sin(1.99/2)sin(-0.29/2)i\"       \"1/sqrt{2}sin(1.2/2)+-1/sqrt{2}c\" ⋯ 225 bytes ⋯ \"1.99/2)cos(1.99/2)sin(-0.29/2)\"\n \"1/sqrt{2}cos(1.2/2)+-1/sqrt{2}-\" ⋯ 233 bytes ⋯ \"99/2)-sin(1.99/2)sin(-0.29/2)i\"     \"1/sqrt{2}sin(1.2/2)+-1/sqrt{2}c\" ⋯ 227 bytes ⋯ \"1.99/2)cos(1.99/2)sin(-0.29/2)\"\n\njulia> mat[1,1]\n\"1/sqrt{2}cos(1.2/2)+1/sqrt{2}-sin(1.2/2)cos(0.69/2)cos(1.99/2)+1/sqrt{2}cos(1.2/2)+1/sqrt{2}-sin(1.2/2)sin(0.69/2)-sin(1.99/2)cos(1.99/2)+1/sqrt{2}cos(1.2/2)+1/sqrt{2}-sin(1.2/2)cos(0.69/2)sin(1.99/2)+1/sqrt{2}cos(1.2/2)+1/sqrt{2}-sin(1.2/2)sin(0.69/2)cos(1.99/2)-sin(1.99/2)cos(-0.29/2)\"\n\n\n\n\n\n","category":"function"},{"location":"#Initprob-utilities","page":"Shovel.jl Documentation","title":"Initprob utilities","text":"","category":"section"},{"location":"","page":"Shovel.jl Documentation","title":"Shovel.jl Documentation","text":"If a quantum computer is simply viewed as a fancy random number generator, the question is: how can we design a circuit such that the measurements have the disired probability distribution. The library considers the measurements as random variable from a multinomial distribution. This distribution is used to approximate other distribution, discrete or continuous.","category":"page"},{"location":"","page":"Shovel.jl Documentation","title":"Shovel.jl Documentation","text":"# Defined in Initprob.jl\r\nshinit1qubit!\r\nshinit2qubits!","category":"page"},{"location":"#Shovel.shinit1qubit!","page":"Shovel.jl Documentation","title":"Shovel.shinit1qubit!","text":"shinit1qubit!(probability::Float64)::QuantumCircuit\n\nWill return a 1 qubit QuantumCircuit initialized such that its probability of being equal to 0 is equal to \"probability\"\n\n\n\n\n\n","category":"function"},{"location":"#Shovel.shinit2qubits!","page":"Shovel.jl Documentation","title":"Shovel.shinit2qubits!","text":"shinit2qubits!(probability::Vector{Float64})::QuantumCircuit\n\nWill return a 2 qubits QuantumCircuit initialize such that the probabilities of the 4 possible outcome are equal to the values provided by the vector \"probabilities\"\n\n\n\n\n\n","category":"function"}]
}
